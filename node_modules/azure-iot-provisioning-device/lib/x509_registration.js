// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var polling_state_machine_1 = require("./polling_state_machine");
var dbg = require("debug");
var debug = dbg('azure-iot-provisioning-device:X509Registration');
/**
 * Client used to run the registration of a device using X509 authentication.
 */
var X509Registration = (function () {
    function X509Registration(provisioningHost, idScope, transport, securityClient) {
        this._provisioningHost = provisioningHost;
        this._idScope = idScope;
        this._transport = transport;
        this._securityClient = securityClient;
        this._pollingStateMachine = new polling_state_machine_1.PollingStateMachine(this._transport);
    }
    /**
     * Register the device with the provisioning service.
     *
     * @param registrationId The registration Id for the device
     * @param forceRegistration Set to true to force re-registration
     * @param callback function called when registration is complete.
     */
    X509Registration.prototype.register = function (callback) {
        var _this = this;
        /* Codes_SRS_NODE_DPS_X509_REGISTRATION_18_001: [ `register` shall call `getCertificate` on the security object to acquire the X509 certificate. ] */
        this._securityClient.getCertificate(function (err, cert) {
            if (err) {
                /* Codes_SRS_NODE_DPS_X509_REGISTRATION_18_006: [ If `getCertificate`fails, `register` shall call `callback` with the error ] */
                debug('security client returned error on cert acquisition');
                callback(err);
            }
            else {
                var registrationId = _this._securityClient.getRegistrationId();
                var request = {
                    registrationId: registrationId,
                    provisioningHost: _this._provisioningHost,
                    idScope: _this._idScope
                };
                /* Codes_SRS_NODE_DPS_X509_REGISTRATION_18_004: [ `register` shall pass the certificate into the `setAuthentication` method on the transport ] */
                _this._transport.setAuthentication(cert);
                /* Codes_SRS_NODE_DPS_X509_REGISTRATION_18_002: [ `register` shall call `registerX509` on the transport object and call it's callback with the result of the transport operation. ] */
                _this._pollingStateMachine.register(request, function (err, result) {
                    _this._pollingStateMachine.disconnect(function (disconnectErr) {
                        if (disconnectErr) {
                            debug('error disconnecting.  Ignoring.  ' + disconnectErr);
                        }
                        if (err) {
                            /* Codes_SRS_NODE_DPS_X509_REGISTRATION_18_005: [ If `register` on the pollingStateMachine fails, `register` shall call `callback` with the error ] */
                            callback(err);
                        }
                        else {
                            callback(null, result.registrationState);
                        }
                    });
                });
            }
        });
    };
    /**
     * Cancels the current registration process.
     *
     * @param callback function called when the registration has already been canceled.
     */
    /* Codes_SRS_NODE_DPS_X509_REGISTRATION_18_003: [ `cancel` shall call `endSession` on the transport object. ] */
    X509Registration.prototype.cancel = function (callback) {
        this._transport.cancel(callback);
    };
    return X509Registration;
}());
exports.X509Registration = X509Registration;
//# sourceMappingURL=x509_registration.js.map