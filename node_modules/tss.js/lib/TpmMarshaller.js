"use strict";
/*
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See the LICENSE file in the project root for full license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var TpmTypes_js_1 = require("./TpmTypes.js");
var SizedStructInfo = (function () {
    function SizedStructInfo(startPos, size) {
        this.startPos = startPos;
        this.size = size;
    }
    return SizedStructInfo;
}());
;
var g_structSize = new Array();
function getCurStuctRemainingSize(curPos) {
    var ssi = g_structSize[g_structSize.length - 1];
    return ssi.size - (curPos - ssi.startPos);
}
exports.getCurStuctRemainingSize = getCurStuctRemainingSize;
var TpmStructure = (function () {
    function TpmStructure() {
    }
    TpmStructure.prototype.asTpm2B = function () {
        var buf = new Buffer(4096);
        var size = this.toTpm(buf, 2);
        toTpm(size - 2, buf, 2, 0);
        return buf.slice(0, size);
    };
    TpmStructure.prototype.asTpm = function () {
        var buf = new Buffer(4096);
        var size = this.toTpm(buf, 0);
        return buf.slice(0, size);
    };
    TpmStructure.prototype.toTpm2B = function (buf, pos) {
        return toTpm2B(this.asTpm(), buf, pos);
    };
    return TpmStructure;
}());
exports.TpmStructure = TpmStructure;
;
/**
 *  Converts the given numerical value of the given size to the TPM wire format.
 *  @param val  Numerical value to marshal
 *  @param buf  Output buffer
 *  @param size  Size of the numerical value in bytes
 *  @param val  Current write position in the output buffer
 *  @returns New write posisition in the output buffer
 */
function toTpm(val, buf, size, pos) {
    // TODO: Replace with Buffer.writeUIntBE()
    if (size >= 4) {
        buf[pos++] = (val >> 24) & 0x000000FF;
        buf[pos++] = (val >> 16) & 0x000000FF;
    }
    if (size >= 2)
        buf[pos++] = (val >> 8) & 0x000000FF;
    buf[pos++] = val & 0x000000FF;
    return pos;
}
exports.toTpm = toTpm;
/**
 *  Reads a numerical value of the given size from the input buffer containg data in the TPM wire format.
 *  @param buf  Input byte buffer
 *  @param size  Size of the numerical value in bytes
 *  @param val  Current read position in the output buffer
 *  @returns A pair containg the extracted numerical value and the new read posisition in the input buffer
 */
function fromTpm(buf, size, pos) {
    if (pos === void 0) { pos = 0; }
    // TODO: Replace with Buffer.readUIntBE()
    var res = 0;
    if (size >= 4) {
        res += (buf[pos++] << 24);
        res += (buf[pos++] << 16);
    }
    if (size >= 2)
        res += (buf[pos++] << 8);
    res += buf[pos++];
    return [res, pos];
}
exports.fromTpm = fromTpm;
/**
 *  Writes the given byte array to the output buffer as a TPM2B structure in the TPM wire format.
 *  @param val  Byte array to marshal
 *  @param buf  Output byte buffer
 *  @param val  Current position in the output buffer
 *  @returns New posisition in the output buffer
 */
function toTpm2B(val, buf, pos) {
    if (val == null)
        pos = toTpm(0, buf, 2, pos);
    else {
        pos = toTpm(val.length, buf, 2, pos);
        val.copy(buf, pos);
        pos += val.length;
    }
    return pos;
}
exports.toTpm2B = toTpm2B;
/**
 *  Reads a byte array from its a TPM2B structure representation in the TPM wire format.
 *  @param buf  Input buffer
 *  @param val  Current position in the output buffer
 *  @returns A pair containg the extracted byte buffer and new posisition in the input buffer
 */
function fromTpm2B(buf, pos) {
    if (pos === void 0) { pos = 0; }
    var len = fromTpm(buf, 2, pos)[0];
    var end = pos + 2 + len;
    return [buf.slice(pos + 2, end), end];
}
exports.fromTpm2B = fromTpm2B;
function createFromTpm(type, buf, pos) {
    var newObj = new type();
    pos = newObj.fromTpm(buf, pos);
    return [newObj, pos];
}
exports.createFromTpm = createFromTpm;
function sizedToTpm(obj, buf, lenSize, pos) {
    if (obj == null)
        return toTpm(0, buf, lenSize, pos);
    // Remember position to marshal the size of the data structure
    var posSize = pos;
    // '+ 2' accounts for the reserved size area
    pos = obj.toTpm(buf, pos + lenSize);
    // Marshal the data structure size
    toTpm(pos - (posSize + lenSize), buf, lenSize, posSize);
    return pos;
}
exports.sizedToTpm = sizedToTpm;
function sizedFromTpm(type, buf, lenSize, pos) {
    var size;
    _a = fromTpm(buf, lenSize, pos), size = _a[0], pos = _a[1];
    if (size == 0)
        return [null, pos];
    g_structSize.push(new SizedStructInfo(pos, size));
    var newObj;
    _b = createFromTpm(type, buf, pos), newObj = _b[0], pos = _b[1];
    g_structSize.pop();
    return [newObj, pos];
    var _a, _b;
}
exports.sizedFromTpm = sizedFromTpm;
function arrayToTpm(arr, buf, lenSize, pos) {
    if (arr == null)
        return toTpm(0, buf, lenSize, pos);
    pos = toTpm(arr.length, buf, lenSize, pos);
    for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
        var elt = arr_1[_i];
        pos = elt.toTpm(buf, pos);
    }
    return pos;
}
exports.arrayToTpm = arrayToTpm;
function arrayFromTpm(type, buf, lenSize, pos) {
    var len;
    _a = fromTpm(buf, lenSize, pos), len = _a[0], pos = _a[1];
    if (len == 0)
        return [[], pos];
    var newArr = new Array(len);
    for (var i = 0; i < len; ++i)
        _b = createFromTpm(type, buf, pos), newArr[i] = _b[0], pos = _b[1];
    return [newArr, pos];
    var _a, _b;
}
exports.arrayFromTpm = arrayFromTpm;
function nonStandardToTpm(s, buf, pos) {
    if (s instanceof TpmTypes_js_1.TPMT_SYM_DEF_OBJECT) {
        var sdo = s;
        pos = toTpm(sdo.algorithm, buf, 2, pos);
        if (sdo.algorithm != TpmTypes_js_1.TPM_ALG_ID.NULL) {
            pos = toTpm(sdo.keyBits, buf, 2, pos);
            pos = toTpm(sdo.mode, buf, 2, pos);
        }
    }
    else if (s instanceof TpmTypes_js_1.TPMT_SYM_DEF) {
        var sd = s;
        pos = toTpm(sd.algorithm, buf, 2, pos);
        if (sd.algorithm != TpmTypes_js_1.TPM_ALG_ID.NULL) {
            pos = toTpm(sd.keyBits, buf, 2, pos);
            pos = toTpm(sd.mode, buf, 2, pos);
        }
    }
    else
        throw new Error("nonStandardMarshallOut(): Unexpected TPM structure type");
    return pos;
}
exports.nonStandardToTpm = nonStandardToTpm;
function nonStandardFromTpm(s, buf, pos) {
    if (s instanceof TpmTypes_js_1.TPMT_SYM_DEF_OBJECT) {
        var sdo = s;
        _a = fromTpm(buf, 2, pos), sdo.algorithm = _a[0], pos = _a[1];
        if (sdo.algorithm != TpmTypes_js_1.TPM_ALG_ID.NULL) {
            _b = fromTpm(buf, 2, pos), sdo.keyBits = _b[0], pos = _b[1];
            _c = fromTpm(buf, 2, pos), sdo.mode = _c[0], pos = _c[1];
        }
    }
    else if (s instanceof TpmTypes_js_1.TPMT_SYM_DEF) {
        var sd = s;
        _d = fromTpm(buf, 2, pos), sd.algorithm = _d[0], pos = _d[1];
        if (sd.algorithm != TpmTypes_js_1.TPM_ALG_ID.NULL) {
            _e = fromTpm(buf, 2, pos), sd.keyBits = _e[0], pos = _e[1];
            _f = fromTpm(buf, 2, pos), sd.mode = _f[0], pos = _f[1];
        }
    }
    else
        throw new Error("nonStandardMarshallIn(): Unexpected TPM structure type");
    return pos;
    var _a, _b, _c, _d, _e, _f;
}
exports.nonStandardFromTpm = nonStandardFromTpm;
