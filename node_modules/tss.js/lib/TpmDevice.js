"use strict";
/*
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See the LICENSE file in the project root for full license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ffi = require('ffi');
var ref = require('ref');
var Struct = require('ref-struct');
var ArrayType = require('ref-array');
var byte = ref.types.byte;
var int = ref.types.int;
exports.ByteArray = ArrayType(byte);
var TbsContext = Struct({
    version: ref.types.int,
    params: ref.types.int
});
var PTbsContext = ref.refType(TbsContext);
var TSS_TPM_INFO;
(function (TSS_TPM_INFO) {
    // Flags corresponding to the TpmEndPointInfo values used by the TPM simulator
    TSS_TPM_INFO[TSS_TPM_INFO["TSS_TpmPlatformAvailable"] = 1] = "TSS_TpmPlatformAvailable";
    TSS_TPM_INFO[TSS_TPM_INFO["TSS_TpmUsesTbs"] = 2] = "TSS_TpmUsesTbs";
    TSS_TPM_INFO[TSS_TPM_INFO["TSS_TpmInRawMode"] = 4] = "TSS_TpmInRawMode";
    TSS_TPM_INFO[TSS_TPM_INFO["TSS_TpmSupportsPP"] = 8] = "TSS_TpmSupportsPP";
    // TPM connection type. Flags are mutually exclusive for better error checking
    TSS_TPM_INFO[TSS_TPM_INFO["TSS_SocketConn"] = 4096] = "TSS_SocketConn";
    TSS_TPM_INFO[TSS_TPM_INFO["TSS_TbsConn"] = 8192] = "TSS_TbsConn";
})(TSS_TPM_INFO = exports.TSS_TPM_INFO || (exports.TSS_TPM_INFO = {}));
;
var TpmLinuxDevice = (function () {
    function TpmLinuxDevice(devTpmHandle) {
        if (devTpmHandle === void 0) { devTpmHandle = TpmLinuxDevice.InvalidHandle; }
        this.devTpmHandle = devTpmHandle;
    }
    TpmLinuxDevice.prototype.connect = function (continuation) {
        if (this.devTpmHandle == TpmLinuxDevice.InvalidHandle) {
            if (TpmLinuxDevice.fs == null)
                TpmLinuxDevice.fs = require('fs');
            this.devTpmHandle = TpmLinuxDevice.fs.openSync('/dev/tpm0', 'rs+');
            //console.log("tpmDevHandle: " + this.devTpmHandle);
        }
        setImmediate(continuation);
        return null;
    };
    TpmLinuxDevice.prototype.dispatchCommand = function (command, continuation) {
        //console.log('Sending ' + command.length + ' bytes to TPM');
        var numWritten = TpmLinuxDevice.fs.writeSync(this.devTpmHandle, command, 0, command.length, null);
        if (numWritten != command.length) {
            var errMsg = 'Only ' + numWritten + ' bytes written to /dev/tpm0 instead of ' + command.length;
            console.log(errMsg);
            throw new Error(errMsg);
        }
        //console.log('Command buffer of ' + numWritten + ' bytes was successfully written');
        var respBuf = new Buffer(4096);
        var numRead = TpmLinuxDevice.fs.readSync(this.devTpmHandle, respBuf, 0, respBuf.length, null);
        //console.log('Response buffer of ' + numRead + ' bytes was read');
        setImmediate(continuation, respBuf.slice(0, numRead));
    };
    TpmLinuxDevice.prototype.close = function () {
        if (this.devTpmHandle != TpmLinuxDevice.InvalidHandle) {
            TpmLinuxDevice.fs.closeSync(this.devTpmHandle);
            this.devTpmHandle = TpmLinuxDevice.InvalidHandle;
        }
    };
    return TpmLinuxDevice;
}());
TpmLinuxDevice.InvalidHandle = -1;
TpmLinuxDevice.fs = null;
exports.TpmLinuxDevice = TpmLinuxDevice;
; // class TpmLinuxDevice
var TpmTbsDevice = (function () {
    function TpmTbsDevice(tbsHandle, tbsDll) {
        if (tbsHandle === void 0) { tbsHandle = 0; }
        if (tbsDll === void 0) { tbsDll = null; }
        this.tbsHandle = tbsHandle;
        this.tbsDll = tbsDll;
    }
    TpmTbsDevice.prototype.connect = function (continuation) {
        this.tbsDll = ffi.Library('Tbs', {
            'Tbsi_Context_Create': ['int', ['pointer', 'pointer']],
            'Tbsip_Context_Close': ['int', ['int']],
            'Tbsip_Submit_Command': ['int', ['int' /*handle*/, 'int' /*locality*/, 'int' /*priority*/,
                    exports.ByteArray /*inBuf*/, 'int' /*inBufLen*/,
                    exports.ByteArray /*outBuf*/, 'pointer' /*outBufLen*/]]
        });
        var tbsCtx = new TbsContext();
        tbsCtx.version = 2;
        tbsCtx.params = 1 << 2;
        //var tbsHandle = ref.NULL;
        var handleOut = ref.alloc('long', 0);
        var res = this.tbsDll.Tbsi_Context_Create(tbsCtx.ref(), handleOut);
        if (res != 0)
            throw (new Error('TBS context cretaion failed. Error '));
        this.tbsHandle = handleOut.deref();
        //console.log("tbsHandle: " + this.tbsHandle)
        setImmediate(continuation);
        return null;
    };
    TpmTbsDevice.prototype.dispatchCommand = function (command, continuation) {
        var respBuf = new exports.ByteArray(4096);
        var respSizePtr = ref.alloc('int', respBuf.length);
        var cmd = new exports.ByteArray(command);
        var res = this.tbsDll.Tbsip_Submit_Command(this.tbsHandle, 0, 0, cmd, command.length, respBuf, respSizePtr);
        var respSize = respSizePtr.deref();
        var response = respBuf.toArray().slice(0, respSize);
        setImmediate(continuation, res == 0 ? new Buffer(response) : null);
    };
    TpmTbsDevice.prototype.close = function () {
        if (this.tbsHandle != 0)
            this.tbsDll.Tbsip_Context_Close(this.tbsHandle);
    };
    return TpmTbsDevice;
}());
exports.TpmTbsDevice = TpmTbsDevice;
; // class TpmTbsDevice
var Net = require("net");
//import * as TPM from "./TpmTypes.js";
var TpmTypes_js_1 = require("./TpmTypes.js");
var TpmMarshaller_js_1 = require("./TpmMarshaller.js");
var ClientVer = 1;
var TPM_TCP_PROTOCOL;
(function (TPM_TCP_PROTOCOL) {
    TPM_TCP_PROTOCOL[TPM_TCP_PROTOCOL["SignalPowerOn"] = 1] = "SignalPowerOn";
    //SignalPowerOff = 2,
    TPM_TCP_PROTOCOL[TPM_TCP_PROTOCOL["SendCommand"] = 8] = "SendCommand";
    TPM_TCP_PROTOCOL[TPM_TCP_PROTOCOL["SignalNvOn"] = 11] = "SignalNvOn";
    //SignalNvOff = 12,
    TPM_TCP_PROTOCOL[TPM_TCP_PROTOCOL["HandShake"] = 15] = "HandShake";
    TPM_TCP_PROTOCOL[TPM_TCP_PROTOCOL["SessionEnd"] = 20] = "SessionEnd";
    TPM_TCP_PROTOCOL[TPM_TCP_PROTOCOL["Stop"] = 21] = "Stop";
})(TPM_TCP_PROTOCOL || (TPM_TCP_PROTOCOL = {}));
;
var TpmTcpDevice = (function () {
    function TpmTcpDevice(host, port) {
        if (host === void 0) { host = '127.0.0.1'; }
        if (port === void 0) { port = 2321; }
        this.tpmInfo = null;
        this.connectCont = null;
        this.dispatchCont = null;
        this.host = host;
        this.port = port;
    }
    TpmTcpDevice.prototype.connect = function (continuation) {
        this.connectCont = continuation;
        this.tpmSocket = new Net.Socket();
        this.tpmSocket.connect(this.port, this.host, this.onConnect.bind(this));
    };
    TpmTcpDevice.prototype.dispatchCommand = function (command, continuation) {
        var curPos = 0;
        var cmdBuf = new Buffer(command.length + 9);
        curPos = TpmMarshaller_js_1.toTpm(TPM_TCP_PROTOCOL.SendCommand, cmdBuf, 4, curPos);
        curPos = TpmMarshaller_js_1.toTpm(0, cmdBuf, 1, curPos); // locality
        curPos = TpmMarshaller_js_1.toTpm(command.length, cmdBuf, 4, curPos);
        command.copy(cmdBuf, curPos);
        this.dispatchCont = continuation;
        this.tcpResp = new Buffer(0);
        this.tpmSocket.removeAllListeners('data');
        this.tpmSocket.on('data', this.onDispatch.bind(this));
        this.tpmSocket.write(cmdBuf);
    };
    TpmTcpDevice.prototype.close = function () {
        if (this.tpmSocket != null) {
            //console.log('Closing the simulator connection...');
            this.tpmSocket.end();
            this.tpmSocket.unref();
            this.tpmSocket = null;
        }
    };
    TpmTcpDevice.prototype.onConnect = function () {
        //console.log('Socket connection to the simulator established');
        this.tcpResp = new Buffer(0);
        this.tpmSocket.on('data', this.onHandShake.bind(this));
        var req = new Buffer([0, 0, 0, TPM_TCP_PROTOCOL.HandShake,
            0, 0, 0, ClientVer]);
        this.tpmSocket.write(req);
    };
    TpmTcpDevice.prototype.onHandShake = function (lastRespFrag) {
        this.tcpResp = Buffer.concat([this.tcpResp, lastRespFrag]);
        if (this.tcpResp.length < 12) {
            //console.log('Incomplete response received: ' + this.tcpResp.length + ' out of 12 bytes. Continue reading...');
            return;
        }
        this.tpmSocket.removeAllListeners('data');
        if (this.tcpResp.length != 12)
            throw new Error('Wrong length of the hand shake response ' + this.tcpResp.length + ' bytes instead of 12');
        var _a = TpmMarshaller_js_1.fromTpm(this.tcpResp, 4, 0), simVer = _a[0], curPos = _a[1];
        if (ClientVer != simVer)
            throw (new Error('Too old server version'));
        _b = TpmMarshaller_js_1.fromTpm(this.tcpResp, 4, curPos), this.tpmInfo = _b[0], curPos = _b[1];
        //console.log('Simulator props: ' + this.tpmInfo);
        var ack;
        _c = TpmMarshaller_js_1.fromTpm(this.tcpResp, 4, curPos), ack = _c[0], curPos = _c[1];
        if (ack != 0)
            throw (new Error('Bad ack from the TPM end point'));
        this.tpmInfo |= TSS_TPM_INFO.TSS_SocketConn;
        this.tpmPlatSocket = new Net.Socket();
        this.tpmPlatSocket.connect(this.port + 1, this.host, this.onPlatConnect.bind(this));
        var _b, _c;
    };
    TpmTcpDevice.prototype.onPlatConnect = function (resp) {
        //console.log('Connected to TPM platform port. Response ' +  resp);
        this.tpmPlatSocket.on('data', this.onPowerOnAck.bind(this));
        var req = new Buffer([0, 0, 0, TPM_TCP_PROTOCOL.SignalPowerOn]);
        this.tpmPlatSocket.write(req);
    };
    TpmTcpDevice.prototype.onPowerOnAck = function (resp) {
        this.tpmPlatSocket.removeAllListeners('data');
        if (resp.length != 4 || TpmMarshaller_js_1.fromTpm(resp, 4)[0] != 0)
            throw (new Error('Bad PowerOn ack from TPM platform end point'));
        //console.log('PowerOn confirmed');
        this.tpmPlatSocket.on('data', this.onNvOnAck.bind(this));
        var req = new Buffer([0, 0, 0, TPM_TCP_PROTOCOL.SignalNvOn]);
        this.tpmPlatSocket.write(req);
    };
    TpmTcpDevice.prototype.onNvOnAck = function (resp) {
        if (resp.length != 4 || TpmMarshaller_js_1.fromTpm(resp, 4)[0] != 0)
            throw (new Error('Bad NvOn ack from TPM platform end point'));
        //console.log('NvOn confirmed');
        var req = new Buffer([0, 0, 0, TPM_TCP_PROTOCOL.SignalNvOn]);
        this.tpmPlatSocket.end();
        this.tpmPlatSocket.unref();
        this.tpmPlatSocket = null;
        this.dispatchCommand(new Buffer([0x80, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x01, 0x44, 0x00, 0x00]), this.onTpmStartup.bind(this));
    };
    TpmTcpDevice.prototype.onTpmStartup = function (resp) {
        this.tpmSocket.removeAllListeners('data');
        if (resp.length != 10)
            throw (new Error('Wrong length of TPM2_Startup() response'));
        var rc = TpmMarshaller_js_1.fromTpm(resp, 4, 6)[0];
        if (rc != TpmTypes_js_1.TPM_RC.SUCCESS && rc != TpmTypes_js_1.TPM_RC.INITIALIZE)
            throw (new Error('Unexpected TPM2_Startup() response ' + TpmTypes_js_1.TPM_RC[rc]));
        setImmediate(this.connectCont);
    };
    TpmTcpDevice.prototype.onDispatch = function (lastRespFrag) {
        this.tcpResp = Buffer.concat([this.tcpResp, lastRespFrag]);
        var respLen = TpmMarshaller_js_1.fromTpm(this.tcpResp, 4)[0];
        if (this.tcpResp.length < respLen + 8) {
            //console.log('Incomplete response received: ' + this.tcpResp.length + ' out of ' + (respLen + 8) + '. Continue reading...');
            return;
        }
        if (respLen != this.tcpResp.length - 8) {
            throw new Error('Invalid size tag in the TPM response TCP packet: '
                + respLen + ' instead of ' + this.tcpResp.length + ' bytes');
        }
        //console.log('TPM returned response of ' + respLen + ' bytes');
        var ack = TpmMarshaller_js_1.fromTpm(this.tcpResp, 4, respLen + 4)[0];
        if (ack != 0)
            throw (new Error('Bad ACK in the TPM response TCP packet: ' + ack + ' instead of 0'));
        var respBuf = new Buffer(this.tcpResp.slice(4, respLen + 4));
        setImmediate(this.dispatchCont, respBuf);
    };
    return TpmTcpDevice;
}());
exports.TpmTcpDevice = TpmTcpDevice;
; // class TpmTcpDevice
