"use strict";
/*
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See the LICENSE file in the project root for full license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var TpmTypes_js_1 = require("./TpmTypes.js");
var TpmDevice_js_1 = require("./TpmDevice.js");
var TpmMarshaller_js_1 = require("./TpmMarshaller.js");
var TpmBase = (function () {
    function TpmBase(useSimulator, host, port) {
        if (useSimulator === void 0) { useSimulator = false; }
        if (host === void 0) { host = '127.0.0.1'; }
        if (port === void 0) { port = 2321; }
        this.LastResponseCode = TpmTypes_js_1.TPM_RC.NOT_USED;
        //
        // Per-command state
        //
        this.Sessions = null;
        this.Device = useSimulator ? new TpmDevice_js_1.TpmTcpDevice(host, port)
            : process.platform == 'win32' ? new TpmDevice_js_1.TpmTbsDevice()
                : new TpmDevice_js_1.TpmLinuxDevice();
    }
    TpmBase.prototype.connect = function (continuation) {
        this.Device.connect(continuation);
    };
    TpmBase.prototype.close = function () {
        this.Device.close();
        this.Device = null;
    };
    TpmBase.isCommMediumError = function (code) {
        // TBS or TPMSim protocol error
        return (code & 0xFFFF0000) == 0x80280000;
    };
    TpmBase.cleanResponseCode = function (rawResponse) {
        if (this.isCommMediumError(rawResponse))
            return rawResponse;
        var mask = (rawResponse & TpmTypes_js_1.TPM_RC.RC_FMT1) != 0
            ? TpmTypes_js_1.TPM_RC.RC_FMT1 | 0x3F : TpmTypes_js_1.TPM_RC.RC_WARN | TpmTypes_js_1.TPM_RC.RC_VER1 | 0x7F;
        return rawResponse & mask;
    };
    TpmBase.prototype.getLastResponseCode = function () {
        return this.LastResponseCode;
    };
    /**
     * For the next TPM command invocation, errors will not cause an exception to be thrown
     * (use _lastCommandSucceeded or _getLastResponseCode() to check for an error)
     *
     * @return The same object (to allow modifier chaining)
     */
    TpmBase.prototype.allowErrors = function () {
        this.AllowErrors = true;
        return this;
    };
    /**
     * Specifies a single session handle to use with the next command
     *
     * @param hh List of up to 3 session handles
     * @return This TPM object
     */
    TpmBase.prototype.withSession = function (sess) {
        this.Sessions = new Array(sess);
        return this;
    };
    /**
     * Specifies the session handles to use with the next command
     *
     * @param hh List of up to 3 session handles
     * @return This TPM object
     */
    TpmBase.prototype.withSessions = function () {
        var sess = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sess[_i] = arguments[_i];
        }
        this.Sessions = new (Array.bind.apply(Array, [void 0].concat(sess)))();
        return this;
    };
    TpmBase.prototype.prepareCmdBuf = function (cmdCode, handles) {
        var cmdBuf = new Buffer(4096);
        var curPos = 0;
        this.CmdTag = this.Sessions != null && this.Sessions.length > 0 ? TpmTypes_js_1.TPM_ST.SESSIONS : TpmTypes_js_1.TPM_ST.NO_SESSIONS;
        curPos = TpmMarshaller_js_1.toTpm(this.CmdTag, cmdBuf, 2, curPos);
        curPos = TpmMarshaller_js_1.toTpm(0, cmdBuf, 4, curPos); // to be filled in later
        curPos = TpmMarshaller_js_1.toTpm(cmdCode, cmdBuf, 4, curPos);
        if (handles != null)
            for (var _i = 0, handles_1 = handles; _i < handles_1.length; _i++) {
                var h = handles_1[_i];
                curPos = h == null ? TpmMarshaller_js_1.toTpm(TpmTypes_js_1.TPM_RH.NULL, cmdBuf, 4, curPos)
                    : h.toTpm(cmdBuf, curPos);
            }
        if (this.CmdTag == TpmTypes_js_1.TPM_ST.SESSIONS) {
            // We do not know the size of the authorization area yet.
            // Remember the place to marshal it, ...
            var authSizePos = curPos;
            // ... and marshal a placeholder value for now.
            //curPos = toTpm(0, cmdBuf, 4, curPos);
            curPos += 4;
            for (var _a = 0, _b = this.Sessions; _a < _b.length; _a++) {
                var sess = _b[_a];
                curPos = sess.SessIn.toTpm(cmdBuf, curPos);
            }
            TpmMarshaller_js_1.toTpm(curPos - authSizePos - 4, cmdBuf, 4, authSizePos);
        }
        this.Sessions = null;
        return [cmdBuf, curPos];
    };
    TpmBase.prototype.InterimResponseHandler = function (respBuf) {
        var rc = TpmMarshaller_js_1.fromTpm(respBuf, 4, 6)[0];
        if (rc == TpmTypes_js_1.TPM_RC.RETRY)
            this.Device.dispatchCommand(this.CmdBuf, this.ResponseHandler.bind(this));
        else
            setImmediate(this.ResponseHandler.bind(this), respBuf);
    };
    TpmBase.prototype.dispatchCommand = function (cmdBuf, responseHandler) {
        // Fill in command buffer size in the command header
        TpmMarshaller_js_1.toTpm(cmdBuf.length, cmdBuf, 4, 2);
        this.ResponseHandler = responseHandler;
        this.CmdBuf = cmdBuf;
        this.Device.dispatchCommand(cmdBuf, this.InterimResponseHandler.bind(this));
    };
    // Returns pair [response parameters size, read position in response buffer]
    TpmBase.prototype.processResponse = function (cmdCode, respBuf) {
        var allowErrors = this.AllowErrors;
        this.AllowErrors = false;
        if (respBuf.length < 10)
            throw (new Error('Response buffer is too short: ' + respBuf.length));
        var tag = TpmMarshaller_js_1.fromTpm(respBuf, 2, 0)[0];
        var respSize = TpmMarshaller_js_1.fromTpm(respBuf, 4, 2)[0];
        var rc = TpmMarshaller_js_1.fromTpm(respBuf, 4, 6)[0];
        var curPos = 10;
        this.LastResponseCode = TpmBase.cleanResponseCode(rc);
        if (rc == TpmTypes_js_1.TPM_RC.SUCCESS && tag != this.CmdTag ||
            rc != TpmTypes_js_1.TPM_RC.SUCCESS && tag != TpmTypes_js_1.TPM_ST.NO_SESSIONS) {
            throw (new Error('Invalid tag in the response buffer: ' + TpmTypes_js_1.TPM_ST[tag] +
                ' for command {' + TpmTypes_js_1.TPM_CC[cmdCode] +
                '} with response code {' + TpmTypes_js_1.TPM_RC[this.LastResponseCode] + '}'));
        }
        if (this.LastResponseCode != TpmTypes_js_1.TPM_RC.SUCCESS) {
            if (!allowErrors) {
                throw (new Error('Command {' + TpmTypes_js_1.TPM_CC[cmdCode] +
                    '} failed with error {' + TpmTypes_js_1.TPM_RC[this.LastResponseCode] + '}'));
            }
            return [0, 10];
        }
        var retHandle = null;
        if (cmdCode == TpmTypes_js_1.TPM_CC.CreatePrimary
            || cmdCode == TpmTypes_js_1.TPM_CC.Load
            || cmdCode == TpmTypes_js_1.TPM_CC.HMAC_Start
            || cmdCode == TpmTypes_js_1.TPM_CC.ContextLoad
            || cmdCode == TpmTypes_js_1.TPM_CC.LoadExternal
            || cmdCode == TpmTypes_js_1.TPM_CC.StartAuthSession
            || cmdCode == TpmTypes_js_1.TPM_CC.HashSequenceStart
            || cmdCode == TpmTypes_js_1.TPM_CC.CreateLoaded) {
            // Response buffer contains a handle returned by the TPM
            _a = TpmMarshaller_js_1.createFromTpm(TpmTypes_js_1.TPM_HANDLE, respBuf, curPos), retHandle = _a[0], curPos = _a[1];
            //assert(retHandle.handle != 0 && retHandle.handle != TPM_RH.UNASSIGNED);
        }
        // If a response session is present, response buffer contains a field specifying the size of response parameters
        var respParamsSize = respBuf.length - curPos;
        if (tag == TpmTypes_js_1.TPM_ST.SESSIONS)
            _b = TpmMarshaller_js_1.fromTpm(respBuf, 4, curPos), respParamsSize = _b[0], curPos = _b[1];
        if (retHandle != null) {
            // A hack to simplify code gen for returned handles handling
            curPos -= 4;
            respParamsSize += 4;
            retHandle.toTpm(respBuf, curPos);
        }
        return [respParamsSize, curPos];
        var _a, _b;
    }; // processResponse()
    return TpmBase;
}());
exports.TpmBase = TpmBase;
; // class TpmBase
